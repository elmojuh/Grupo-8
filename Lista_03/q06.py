# -*- coding: utf-8 -*-
"""Resumo Árvores.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1gPfl-YOSCkbfLCj5qgm-cRtGGdfxcFcZ

# Árvores




> *São Estruturas de Dados que herda as características das topologias(hierarquias) em árvore.

### Árvore Binária de Busca


> *É um tipo de árvore é estruturada de forma binária.*

Nela temos:
  - Organização hieráquica de chaves ordenáveis
  - Algorítmo de busca análogo à busca binária.

  Possui também problemas a serem cidados. Como o algoritmo rodar em tempo O(n) no pior caso. Já que a altura crece linearmente no pior caso.

Dela surge as árvores autobalanceadas.
"""


# Algoritmo da BST com os principais métodos em Python
# Fonte: https://gist.github.com/divanibarbosa/a8662693e44ab9ee0d0e8c2d74808929


class No:

    def __init__(self, key, dir, esq):
        self.item = key
        self.dir = dir
        self.esq = esq


class Tree:

    def __init__(self):
        self.root = No(None, None, None)
        self.root = None

    def inserir(self, v):
        novo = No(v, None, None)  # cria um novo Nó
        if self.root == None:
            self.root = novo
        else:  # se nao for a raiz
            atual = self.root
            while True:
                anterior = atual
                if v <= atual.item:  # ir para esquerda
                    atual = atual.esq
                    if atual == None:
                        anterior.esq = novo
                        return
                # fim da condição ir a esquerda
                else:  # ir para direita
                    atual = atual.dir
                    if atual == None:
                        anterior.dir = novo
                        return
                # fim da condição ir a direita

    def buscar(self, chave):
        if self.root == None:
            return None  # se arvore vazia
        atual = self.root  # começa a procurar desde raiz
        while atual.item != chave:  # enquanto nao encontrou
            if chave < atual.item:
                atual = atual.esq  # caminha para esquerda
            else:
                atual = atual.dir  # caminha para direita
            if atual == None:
                return None  # encontrou uma folha -> sai
        return atual  # terminou o laço while e chegou aqui é pq encontrou item

    # O sucessor é o Nó mais a esquerda da subarvore a direita do No que foi passado como parametro do metodo
    def nosucessor(self, apaga):  # O parametro é a referencia para o No que deseja-se apagar
        paidosucessor = apaga
        sucessor = apaga
        atual = apaga.dir  # vai para a subarvore a direita

        while atual != None:  # enquanto nao chegar no Nó mais a esquerda
            paidosucessor = sucessor
            sucessor = atual
            atual = atual.esq  # caminha para a esquerda

        # *********************************************************************************
        # quando sair do while "sucessor" será o Nó mais a esquerda da subarvore a direita
        # "paidosucessor" será o o pai de sucessor e "apaga" o Nó que deverá ser eliminado
        # *********************************************************************************
        if sucessor != apaga.dir:  # se sucessor nao é o filho a direita do Nó que deverá ser eliminado
            paidosucessor.esq = sucessor.dir  # pai herda os filhos do sucessor que sempre serão a direita
            # lembrando que o sucessor nunca poderá ter filhos a esquerda, pois, ele sempre será o
            # Nó mais a esquerda da subarvore a direita do Nó apaga.
            # lembrando também que sucessor sempre será o filho a esquerda do pai
            sucessor.dir = apaga.dir  # guardando a referencia a direita do sucessor para
            # quando ele assumir a posição correta na arvore
        return sucessor

    def remover(self, v):
        if self.root == None:
            return False  # se arvore vazia
        atual = self.root
        pai = self.root
        filho_esq = True
        # ****** Buscando o valor **********
        while atual.item != v:  # enquanto nao encontrou
            pai = atual
            if v < atual.item:  # caminha para esquerda
                atual = atual.esq
                filho_esq = True  # é filho a esquerda? sim
            else:  # caminha para direita
                atual = atual.dir
                filho_esq = False  # é filho a esquerda? NAO
            if atual == None:
                return False  # encontrou uma folha -> sai
        # fim laço while de busca do valor

        # **************************************************************
        # se chegou aqui quer dizer que encontrou o valor (v)
        # "atual": contem a referencia ao No a ser eliminado
        # "pai": contem a referencia para o pai do No a ser eliminado
        # "filho_esq": é verdadeiro se atual é filho a esquerda do pai
        # **************************************************************

        # Se nao possui nenhum filho (é uma folha), elimine-o
        if atual.esq == None and atual.dir == None:
            if atual == self.root:
                self.root = None  # se raiz
            else:
                if filho_esq:
                    pai.esq = None  # se for filho a esquerda do pai
                else:
                    pai.dir = None  # se for filho a direita do pai

        # Se é pai e nao possui um filho a direita, substitui pela subarvore a direita
        elif atual.dir == None:
            if atual == self.root:
                self.root = atual.esq  # se raiz
            else:
                if filho_esq:
                    pai.esq = atual.esq  # se for filho a esquerda do pai
                else:
                    pai.dir = atual.esq  # se for filho a direita do pai

        # Se é pai e nao possui um filho a esquerda, substitui pela subarvore a esquerda
        elif atual.esq == None:
            if atual == self.root:
                self.root = atual.dir  # se raiz
            else:
                if filho_esq:
                    pai.esq = atual.dir  # se for filho a esquerda do pai
                else:
                    pai.dir = atual.dir  # se for  filho a direita do pai

        # Se possui mais de um filho, se for um avô ou outro grau maior de parentesco
        else:
            sucessor = self.nosucessor(atual)
            # Usando sucessor que seria o Nó mais a esquerda da subarvore a direita do No que deseja-se remover
            if atual == self.root:
                self.root = sucessor  # se raiz
            else:
                if filho_esq:
                    pai.esq = sucessor  # se for filho a esquerda do pai
                else:
                    pai.dir = sucessor  # se for filho a direita do pai
            sucessor.esq = atual.esq  # acertando o ponteiro a esquerda do sucessor agora que ele assumiu
            # a posição correta na arvore

        return True

    def inOrder(self, atual):
        if atual != None:
            self.inOrder(atual.esq)
            print(atual.item, end=" ")
            self.inOrder(atual.dir)

    def preOrder(self, atual):
        if atual != None:
            print(atual.item, end=" ")
            self.preOrder(atual.esq)
            self.preOrder(atual.dir)

    def posOrder(self, atual):
        if atual != None:
            self.posOrder(atual.esq)
            self.posOrder(atual.dir)
            print(atual.item, end=" ")

    def altura(self, atual):
        if atual == None or atual.esq == None and atual.dir == None:
            return 0
        else:
            if self.altura(atual.esq) > self.altura(atual.dir):
                return 1 + self.altura(atual.esq)
            else:
                return 1 + self.altura(atual.dir)

    def folhas(self, atual):
        if atual == None:
            return 0
        if atual.esq == None and atual.dir == None:
            return 1
        return self.folhas(atual.esq) + self.folhas(atual.dir)

    def contarNos(self, atual):
        if atual == None:
            return 0
        else:
            return 1 + self.contarNos(atual.esq) + self.contarNos(atual.dir)

    def minn(self):
        atual = self.root
        anterior = None
        while atual != None:
            anterior = atual
            atual = atual.esq
        return anterior

    def maxx(self):
        atual = self.root
        anterior = None
        while atual != None:
            anterior = atual
            atual = atual.dir
        return anterior

    def caminhar(self):
        print(" Exibindo em ordem: ", end="")
        self.inOrder(self.root)
        print("\n Exibindo em pos-ordem: ", end="")
        self.posOrder(self.root)
        print("\n Exibindo em pre-ordem: ", end="")
        self.preOrder(self.root)
        print("\n Altura da arvore: %d" % (self.altura(self.root)))
        print(" Quantidade de folhas: %d" % (self.folhas(self.root)))
        print(" Quantidade de Nós: %d" % (self.contarNos(self.root)))
        if self.root != None:  # se arvore nao esta vazia
            print(" Valor minimo: %d" % (self.minn().item))
            print(" Valor maximo: %d" % (self.maxx().item))


#### fim da classe ####

arv = Tree()
print("Programa Arvore Binaria")
opcao = 0
while opcao != 5:
    print("***********************************")
    print("Entre com a opcao:")
    print(" --- 1: Inserir")
    print(" --- 2: Excluir")
    print(" --- 3: Pesquisar")
    print(" --- 4: Exibir")
    print(" --- 5: Sair do programa")
    print("***********************************")
    opcao = int(input("-> "))
    if opcao == 1:
        x = int(input(" Informe o valor -> "))
        arv.inserir(x)
    elif opcao == 2:
        x = int(input(" Informe o valor -> "))
        if arv.remover(x) == False:
            print(" Valor nao encontrado!")
    elif opcao == 3:
        x = int(input(" Informe o valor -> "))
        if arv.buscar(x) != None:
            print(" Valor Encontrado")
        else:
            print(" Valor nao encontrado!")
    elif opcao == 4:
        arv.caminhar()
    elif opcao == 5:
        break

"""### Árvore AVL


> *É um tipo de árvore que os algoritmos de inserção e remoção mantêm os nós da árvore equilibrados.
  - Mantém a complexidade já que a árvore sempre está equilibrada com o fator de equilíbrio. Sempre mantem a diferença de altura em cada subárvore menor que 2.
  - Sua complexidade se mantém em O(log n)





"""

"""Arvore AVL em Python"""


class No:
    def __init__(self, data):
        self.data = data
        self.setaFilhos(None, None)

    def setaFilhos(self, esquerda, direita):
        self.esquerda = esquerda
        self.direita = direita

    def balanco(self):
        prof_esq = 0
        if self.esquerda:
            prof_esq = self.esquerda.profundidade()
        prof_dir = 0
        if self.direita:
            prof_dir = self.direita.profundidade()
        return prof_esq - prof_dir

    def profundidade(self):
        prof_esq = 0
        if self.esquerda:
            prof_esq = self.esquerda.profundidade()
        prof_dir = 0
        if self.direita:
            prof_dir = self.direita.profundidade()
        return 1 + max(prof_esq, prof_dir)

    def rotacaoEsquerda(self):
        self.data, self.direita.data = self.direita.data, self.data
        old_esquerda = self.esquerda
        self.setaFilhos(self.direita, self.direita.direita)
        self.esquerda.setaFilhos(old_esquerda, self.esquerda.esquerda)

    def rotacaoDireita(self):
        self.data, self.esquerda.data = self.esquerda.data, self.data
        old_direita = self.direita
        self.setaFilhos(self.esquerda.esquerda, self.esquerda)
        self.direita.setaFilhos(self.direita.direita, old_direita)

    def rotacaoEsquerdaDireita(self):
        self.esquerda.rotacaoEsquerda()
        self.rotacaoDireita()

    def rotacaoDireitaEsquerda(self):
        self.direita.rotacaoDireita()
        self.rotacaoEsquerda()

    def executaBalanco(self):
        bal = self.balanco()
        if bal > 1:
            if self.esquerda.balanco() > 0:
                self.rotacaoDireita()
            else:
                self.rotacaoEsquerdaDireita()
        elif bal < -1:
            if self.direita.balanco() < 0:
                self.rotacaoEsquerda()
            else:
                self.rotacaoDireitaEsquerda()

    def insere(self, data):
        if data <= self.data:
            if not self.esquerda:
                self.esquerda = No(data)
            else:
                self.esquerda.insere(data)
        else:
            if not self.direita:
                self.direita = No(data)
            else:
                self.direita.insere(data)
        self.executaBalanco()

    def imprimeArvore(self, indent=0):
        print
        " " * indent + str(self.data)
        if self.esquerda:
            self.esquerda.imprimeArvore(indent + 2)
        if self.direita:
            self.direita.imprimeArvore(indent + 2)


"""### Árvore Rubro Negra


> *É um tipo de árvore 2 nós com algumas particularidades.
  - É autobalanceada, como toda arvore autobalanceada.
  - Enlaces são representados pela cor Negra e Vermelha.
  - Nenhum nó possui dois enlaces vermelhos.
  - Todos os caminhos até os nós nulos têm o mesmo número de ençaces negros (assim tendo o equilíbrio negro perfeito).
  - Um pouco mais complexa de ser implementada.

Algumas outras particularidades são:
  - Todo nó que possui um nó filho, o enlace entre os dois dev ser vermelho;
  - Filhos únicos são sempre filhos à esquerda; senão enlace vermelho para a direita;
  - Todo filho via enlace vermelho possui dois filhos ou nenhum; se um só filho, outro enlace vermelho.

Curiosidade:
  - Altura de uma árvore rubro-negra é, no máximo, o dobro da arvore 2-3 correspondente;
  - Possui enlaces alternados negros e vermelhos com H=O(log n);





"""


class RedBlackTreeNode(object):
    def __init__(self, val):
        self.val = val
        self.left = None
        self.right = None
        self.size = 1
        self.isRed = True


class RedBlackTree(object):
    def __init__(self):
        self.root = None

    def sizeOf(self, node):
        return node.size if node else 0

    @property
    def size(self):
        return self.sizeOf(self.root)

    def rotateLeft(self, root):
        right = root.right

        root.size, right.size = self.sizeOf(
            root.left) + self.sizeOf(right.left) + 1, root.size

        root.right = right.left
        right.left = root

        right.isRed = root.isRed
        root.isRed = True

        return right

    def rotateRight(self, root):
        left = root.left

        root.size, left.size = self.sizeOf(
            root.right) + self.sizeOf(left.right) + 1, root.size

        root.left = left.right
        left.right = root

        left.isRed = root.isRed
        root.isRed = True

        return left

    def flipColor(self, root):
        root.left.isRed = False
        root.right.isRed = False
        root.isRed = True
        return root

    def insertTo(self, root, val):
        if not root:
            return RedBlackTreeNode(val)

        if val > root.val:
            root.right = self.insertTo(root.right, val)
        else:
            root.left = self.insertTo(root.left, val)

        if (root.right and root.right.isRed) and not (
                root.left and root.left.isRed):
            root = self.rotateLeft(root)

        if (root.left and root.left.isRed) and (
                root.left.left and root.left.left.isRed):
            root = self.rotateRight(root)

        if (root.left and root.left.isRed) and (
                root.right and root.right.isRed):
            root = self.flipColor(root)

        root.size = sum(map(self.sizeOf, (root.left, root.right))) + 1
        return root

    def insert(self, val):
        self.root = self.insertTo(self.root, val)
        self.root.isRed = False

    def searchK(self, k, root=None):
        root = root or self.root

        size = self.sizeOf(root.left) + 1
        if k == size:
            return root.val

        return self.searchK(k, root.left) if k < size else self.searchK(
            k - size, root.right)
